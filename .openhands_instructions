You are working on a Garage Inventory Management System built with Angular frontend and .NET backend using Onion Architecture.

## CRITICAL - ALWAYS COMMIT YOUR WORK

After making ANY changes to files, you MUST commit them:

1. Run: `git add -A`
2. Run: `git commit -m "feat: [description of what you did]"`
3. The GitHub Action will automatically create the PR after you commit

**WITHOUT COMMITTING, YOUR WORK WILL BE LOST!**

## ISSUE PIPELINE SYSTEM

This project uses a sequential issue pipeline:
- Only ONE issue has the `fix-me` label at a time
- When your PR is merged, the NEXT issue automatically gets the `fix-me` label
- This ensures proper TDD workflow and prevents conflicts between agents
- Focus ONLY on your assigned issue - don't worry about future steps

## PROJECT ARCHITECTURE

### Backend (.NET) - Onion Architecture

- **Domain Layer** (`src/GarageInventory.Domain/`): Entities, domain interfaces, business rules
- **Application Layer** (`src/GarageInventory.Application/`): DTOs, services, use cases, application interfaces
- **Infrastructure Layer** (`src/GarageInventory.Infrastructure/`): Data access, repositories, external services
- **API Layer** (`src/GarageInventory.API/`): Controllers, middleware, API configuration

### Frontend (Angular)

- **Location**: `frontend/src/app/`
- **Structure**:
  - `core/` - Singleton services, guards, interceptors
  - `shared/` - Reusable components, pipes, directives
  - `features/` - Feature modules (auth/, inventory/, locations/)
  - `layout/` - App layout components (header/, sidebar/)

## FRONTEND DEVELOPMENT GUIDELINES

### Creating/Modifying Angular Components

1. **Use Standalone Components** (Angular 14+ style)

```typescript
import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatButtonModule } from '@angular/material/button';

@Component({
  selector: 'app-component-name',
  standalone: true,
  imports: [CommonModule, MatButtonModule],
  templateUrl: './component-name.component.html',
  styleUrl: './component-name.component.scss'
})
export class ComponentNameComponent {}
```

2. **Follow Angular Material Design**
   - Import required Material modules
   - Use Material components for consistency
   - Follow the existing theme and styling patterns

3. **Component Best Practices**
   - Use OnPush change detection when possible
   - Implement proper TypeScript interfaces
   - Handle loading states and errors
   - Unsubscribe from observables properly
   - Write semantic, accessible HTML

4. **File Naming Convention**
   - Components: `feature-name.component.ts`
   - Services: `feature-name.service.ts`
   - Templates: `feature-name.component.html`
   - Styles: `feature-name.component.scss`

### Routing

- Update `app.routes.ts` when adding new routes
- Use lazy loading for feature modules when appropriate
- Implement route guards for protected routes

## BACKEND DEVELOPMENT GUIDELINES

### Creating API Endpoints

1. **Controller Structure** (`src/GarageInventory.API/Controllers/`)

```csharp
using Microsoft.AspNetCore.Mvc;
using GarageInventory.Application.DTOs;
using GarageInventory.Application.Interfaces;

namespace GarageInventory.API.Controllers;

[ApiController]
[Route("api/[controller]")]
public class ResourceController : ControllerBase
{
    private readonly IResourceService _service;
    
    public ResourceController(IResourceService service)
    {
        _service = service;
    }
    
    [HttpGet]
    public async Task<IActionResult> GetAll()
    {
        var result = await _service.GetAllAsync();
        return Ok(result);
    }
}
```

2. **Service Layer** (`src/GarageInventory.Application/Services/`)
   - Implement business logic in services
   - Use DTOs for data transfer
   - Handle validation and business rules
   - Return appropriate response types

3. **Repository Pattern** (`src/GarageInventory.Infrastructure/Repositories/`)
   - Implement data access logic
   - Use Entity Framework Core
   - Follow repository interfaces from Domain layer

4. **DTO Pattern** (`src/GarageInventory.Application/DTOs/`)
   - Create separate DTOs for requests and responses
   - Use AutoMapper for entity-DTO mapping
   - Include validation attributes

## CODE QUALITY STANDARDS

### General Requirements

- Write clean, self-documenting code
- Follow SOLID principles
- Implement proper error handling
- Add logging where appropriate
- Use async/await for I/O operations
- Follow Test-Driven Development (TDD) when implementing new features

### Angular Specific

- Use RxJS operators effectively
- Implement proper form validation
- Handle HTTP errors gracefully
- Use TypeScript strict mode
- Follow Angular Style Guide

### .NET Specific

- Use dependency injection
- Implement proper exception handling
- Follow RESTful API conventions
- Use appropriate HTTP status codes
- Validate input data

## TEST-DRIVEN DEVELOPMENT (TDD)

### TDD Workflow - MANDATORY for new features

1. **RED**: Write a failing test first - CHECK OTHER ISSUES to see if tests exist
2. **GREEN**: Write minimal code to make the test pass  
3. **REFACTOR**: Improve the code while keeping tests green

CRITICAL: Before implementing ANY feature, check if test issues exist and are completed.
If test issues are still open, COMMENT on this issue that you're waiting for tests to be completed first.

DEPENDENCY CHECK REQUIRED:
1. Look at your issue title - if it says "Step X:", check if Steps 1 through X-1 are completed
2. Search for related issues with lower step numbers
3. If prerequisite steps are still open, STOP and comment: "Waiting for Step [X] to complete before proceeding"
4. Only work on issues where all dependencies are satisfied

### Implementation Order

1. Write the test file first (`.spec.ts` for Angular, `.Tests.cs` for .NET)
2. Define what the feature should do through tests
3. Implement the actual feature to satisfy the tests
4. Refactor for clarity and performance

### Frontend Testing (Angular)

```typescript
// Write test first - example.component.spec.ts
it('should display welcome message', () => {
  const compiled = fixture.nativeElement;
  expect(compiled.querySelector('h1')?.textContent).toContain('Welcome');
});
```

### Backend Testing (.NET)

```csharp
// Write test first - ExampleServiceTests.cs
[Test]
public async Task GetItems_ShouldReturnFilteredResults()
{
    // Arrange
    var service = new ItemService(_mockRepo.Object);
    
    // Act
    var result = await service.GetItemsAsync("search");
    
    // Assert
    Assert.That(result.Count(), Is.EqualTo(2));
}
```

## TESTING STANDARDS

1. **Frontend Tests**
   - Component tests with Jasmine/Karma
   - Service tests with HTTP mocking
   - E2E tests for critical user flows
   - Minimum 80% code coverage for components

2. **Backend Tests**
   - Unit tests for services and domain logic
   - Integration tests for API endpoints
   - Repository tests with in-memory database
   - Minimum 80% code coverage for business logic

## HANDLING "NO CHANGES NEEDED" SCENARIOS

If you determine that an issue requires NO code changes:
1. Create an empty commit to maintain pipeline flow:
   ```bash
   git commit --allow-empty -m "chore: verify implementation - no changes needed
   
   Issue #XXX already satisfied by existing implementation.
   All acceptance criteria met."
   ```
2. This allows the pipeline to continue automatically
3. Document WHY no changes were needed in the commit message

# WORKFLOW BEST PRACTICES

1. **Before Starting**
   - Understand the existing codebase structure
   - Check for similar implementations to follow patterns
   - Review related files for context
   - **Write tests FIRST (TDD approach)**

2. **During Development**
   - Follow RED-GREEN-REFACTOR cycle
   - Write failing test → Make it pass → Improve code
   - Make incremental changes
   - Run tests frequently to ensure nothing breaks
   - Keep commits focused and atomic
   - Update related files (routes, imports, etc.)

3. **Before Committing**
   - Ensure ALL tests pass
   - Ensure code compiles without errors
   - Check for proper imports and dependencies
   - Verify file naming conventions
   - Remove any debug code or console.logs
   - Confirm test coverage meets requirements

## DOCUMENTATION REQUIREMENTS

### When to Update Documentation

You MUST update relevant documentation when:

1. **Adding New Features**
   - Update README.md with new feature description
   - Add/update relevant sections in docs/
   - Update API documentation if new endpoints added
   - Document new environment variables or configuration

2. **Changing Architecture**
   - Update architecture diagrams
   - Document new patterns or practices
   - Update folder structure documentation
   - Modify development guidelines

3. **Modifying APIs**
   - Update OpenAPI/Swagger specifications
   - Document request/response changes
   - Update error code documentation
   - Add examples for new endpoints

4. **Adding Dependencies**
   - Update package.json or .csproj documentation
   - Document why the dependency was added
   - Include configuration requirements
   - Update installation instructions

5. **Changing Configuration**
   - Update environment variable documentation
   - Document new settings or options
   - Update docker-compose if needed
   - Modify deployment documentation

### Documentation Standards

1. **Code Documentation**
   ```typescript
   /**
    * Service for managing user authentication
    * @description Handles login, logout, and token management
    */
   ```
   
   ```csharp
   /// <summary>
   /// Retrieves inventory items for the authenticated user
   /// </summary>
   /// <param name="filter">Optional filter criteria</param>
   /// <returns>List of inventory items</returns>
   ```

2. **README Updates**
   - Keep feature list current
   - Update setup instructions if process changes
   - Document new environment variables
   - Add troubleshooting for new issues

3. **API Documentation**
   - Use JSDoc for TypeScript/JavaScript
   - Use XML comments for C#/.NET
   - Include request/response examples
   - Document error scenarios

4. **Inline Comments**
   - Explain complex business logic
   - Document workarounds or temporary solutions
   - Add TODO comments for future improvements
   - Reference issue numbers for context

### Documentation Checklist

Before committing, verify:
- [ ] README.md reflects any new features or changes
- [ ] API documentation updated for new/changed endpoints
- [ ] Code comments added for complex logic
- [ ] Configuration changes documented
- [ ] Migration steps documented if needed
- [ ] Test documentation updated
- [ ] Architecture diagrams current (if applicable)

## AVOID

- Creating files in wrong directories
- Forgetting to update module imports
- Hardcoding values that should be configurable
- Skipping error handling
- Creating overly complex solutions for simple problems
- **FORGETTING TO COMMIT YOUR CHANGES**
- **FORGETTING TO UPDATE DOCUMENTATION**

Remember: Focus on delivering working, maintainable code that follows the established patterns in the codebase, and keep documentation current for future developers and AI agents.
