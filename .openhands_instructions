You are working on a Garage Inventory Management System built with Angular frontend and .NET backend using Onion Architecture.

## CRITICAL - ALWAYS COMMIT YOUR WORK

After making ANY changes to files, you MUST commit them:

1. Run: `git add -A`
2. Run: `git commit -m "feat: [description of what you did]"`
3. The GitHub Action will automatically create the PR after you commit

**WITHOUT COMMITTING, YOUR WORK WILL BE LOST!**

## ISSUE PIPELINE SYSTEM

This project uses a sequential issue pipeline:
- Only ONE issue has the `fix-me` label at a time
- When your PR is merged, the NEXT issue automatically gets the `fix-me` label
- This ensures proper TDD workflow and prevents conflicts between agents
- Focus ONLY on your assigned issue - don't worry about future steps

## PROJECT ARCHITECTURE

### Backend (.NET) - Onion Architecture

- **Domain Layer** (`src/GarageInventory.Domain/`): Entities, domain interfaces, business rules
- **Application Layer** (`src/GarageInventory.Application/`): DTOs, services, use cases, application interfaces
- **Infrastructure Layer** (`src/GarageInventory.Infrastructure/`): Data access, repositories, external services
- **API Layer** (`src/GarageInventory.API/`): Controllers, middleware, API configuration

### Frontend (Angular)

- **Location**: `frontend/src/app/`
- **Structure**:
  - `core/` - Singleton services, guards, interceptors
  - `shared/` - Reusable components, pipes, directives
  - `features/` - Feature modules (auth/, inventory/, locations/)
  - `layout/` - App layout components (header/, sidebar/)

## FRONTEND DEVELOPMENT GUIDELINES

### Creating/Modifying Angular Components

1. **Use Standalone Components** (Angular 14+ style)

```typescript
import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatButtonModule } from '@angular/material/button';

@Component({
  selector: 'app-component-name',
  standalone: true,
  imports: [CommonModule, MatButtonModule],
  templateUrl: './component-name.component.html',
  styleUrl: './component-name.component.scss'
})
export class ComponentNameComponent {}
```

2. **Follow Angular Material Design**
   - Import required Material modules
   - Use Material components for consistency
   - Follow the existing theme and styling patterns

3. **Component Best Practices**
   - Use OnPush change detection when possible
   - Implement proper TypeScript interfaces
   - Handle loading states and errors
   - Unsubscribe from observables properly
   - Write semantic, accessible HTML

4. **File Naming Convention**
   - Components: `feature-name.component.ts`
   - Services: `feature-name.service.ts`
   - Templates: `feature-name.component.html`
   - Styles: `feature-name.component.scss`

### Routing

- Update `app.routes.ts` when adding new routes
- Use lazy loading for feature modules when appropriate
- Implement route guards for protected routes

## BACKEND DEVELOPMENT GUIDELINES

### Creating API Endpoints

1. **Controller Structure** (`src/GarageInventory.API/Controllers/`)

```csharp
using Microsoft.AspNetCore.Mvc;
using GarageInventory.Application.DTOs;
using GarageInventory.Application.Interfaces;

namespace GarageInventory.API.Controllers;

[ApiController]
[Route("api/[controller]")]
public class ResourceController : ControllerBase
{
    private readonly IResourceService _service;
    
    public ResourceController(IResourceService service)
    {
        _service = service;
    }
    
    [HttpGet]
    public async Task<IActionResult> GetAll()
    {
        var result = await _service.GetAllAsync();
        return Ok(result);
    }
}
```

2. **Service Layer** (`src/GarageInventory.Application/Services/`)
   - Implement business logic in services
   - Use DTOs for data transfer
   - Handle validation and business rules
   - Return appropriate response types

3. **Repository Pattern** (`src/GarageInventory.Infrastructure/Repositories/`)
   - Implement data access logic
   - Use Entity Framework Core
   - Follow repository interfaces from Domain layer

4. **DTO Pattern** (`src/GarageInventory.Application/DTOs/`)
   - Create separate DTOs for requests and responses
   - Use AutoMapper for entity-DTO mapping
   - Include validation attributes

## CODE QUALITY STANDARDS

### General Requirements

- Write clean, self-documenting code
- Follow SOLID principles
- Implement proper error handling
- Add logging where appropriate
- Use async/await for I/O operations
- Follow Test-Driven Development (TDD) when implementing new features

### Angular Specific

- Use RxJS operators effectively
- Implement proper form validation
- Handle HTTP errors gracefully
- Use TypeScript strict mode
- Follow Angular Style Guide

### .NET Specific

- Use dependency injection
- Implement proper exception handling
- Follow RESTful API conventions
- Use appropriate HTTP status codes
- Validate input data

## TEST-DRIVEN DEVELOPMENT (TDD)

### TDD Workflow - MANDATORY for new features

1. **RED**: Write a failing test first - CHECK OTHER ISSUES to see if tests exist
2. **GREEN**: Write minimal code to make the test pass  
3. **REFACTOR**: Improve the code while keeping tests green

CRITICAL: Before implementing ANY feature, check if test issues exist and are completed.
If test issues are still open, COMMENT on this issue that you're waiting for tests to be completed first.

DEPENDENCY CHECK REQUIRED:
1. Look at your issue title - if it says "Step X:", check if Steps 1 through X-1 are completed
2. Search for related issues with lower step numbers
3. If prerequisite steps are still open, STOP and comment: "Waiting for Step [X] to complete before proceeding"
4. Only work on issues where all dependencies are satisfied

### Implementation Order

1. Write the test file first (`.spec.ts` for Angular, `.Tests.cs` for .NET)
2. Define what the feature should do through tests
3. Implement the actual feature to satisfy the tests
4. Refactor for clarity and performance

### Frontend Testing (Angular)

```typescript
// Write test first - example.component.spec.ts
it('should display welcome message', () => {
  const compiled = fixture.nativeElement;
  expect(compiled.querySelector('h1')?.textContent).toContain('Welcome');
});
```

### Backend Testing (.NET)

```csharp
// Write test first - ExampleServiceTests.cs
[Test]
public async Task GetItems_ShouldReturnFilteredResults()
{
    // Arrange
    var service = new ItemService(_mockRepo.Object);
    
    // Act
    var result = await service.GetItemsAsync("search");
    
    // Assert
    Assert.That(result.Count(), Is.EqualTo(2));
}
```

## TESTING STANDARDS

1. **Frontend Tests**
   - Component tests with Jasmine/Karma
   - Service tests with HTTP mocking
   - E2E tests for critical user flows
   - Minimum 80% code coverage for components

2. **Backend Tests**
   - Unit tests for services and domain logic
   - Integration tests for API endpoints
   - Repository tests with in-memory database
   - Minimum 80% code coverage for business logic

## WORKFLOW BEST PRACTICES

1. **Before Starting**
   - Understand the existing codebase structure
   - Check for similar implementations to follow patterns
   - Review related files for context
   - **Write tests FIRST (TDD approach)**

2. **During Development**
   - Follow RED-GREEN-REFACTOR cycle
   - Write failing test → Make it pass → Improve code
   - Make incremental changes
   - Run tests frequently to ensure nothing breaks
   - Keep commits focused and atomic
   - Update related files (routes, imports, etc.)

3. **Before Committing**
   - Ensure ALL tests pass
   - Ensure code compiles without errors
   - Check for proper imports and dependencies
   - Verify file naming conventions
   - Remove any debug code or console.logs
   - Confirm test coverage meets requirements

## AVOID

- Creating files in wrong directories
- Forgetting to update module imports
- Hardcoding values that should be configurable
- Skipping error handling
- Creating overly complex solutions for simple problems
- **FORGETTING TO COMMIT YOUR CHANGES**

Remember: Focus on delivering working, maintainable code that follows the established patterns in the codebase.
