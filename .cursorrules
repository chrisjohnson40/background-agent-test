# Cursor AI Rules for Garage Inventory Management System

## Project Overview

This is an Angular + .NET garage inventory management system using Onion Architecture, with support for multiple background agents.

## Architecture Guidelines

### Backend (.NET API)

- **Follow Onion Architecture strictly**:
  - Core/Domain: Business entities, interfaces, domain services
  - Application: Use cases, DTOs, application services
  - Infrastructure: Data access, external services, repositories
  - Presentation: Controllers, middleware, API configuration
- Use **Entity Framework Core** with Code-First approach
- Implement **CQRS pattern** for complex operations
- Use **MediatR** for request/response handling
- Apply **Repository pattern** for data access
- Implement **Unit of Work** pattern for transactions

### Frontend (Angular)

- Follow **Angular Style Guide**
- Use **Standalone components** (Angular 14+)
- Implement **OnPush change detection** where possible
- Use **RxJS** for reactive programming
- Apply **Feature-based folder structure**
- Use **Angular Material** for UI components
- Implement **State management** with NgRx (if needed)

### Database Design

- Use **PostgreSQL** as primary database
- Apply **proper normalization** (3NF minimum)
- Use **meaningful naming conventions**
- Implement **soft deletes** for audit trails
- Add **created/updated timestamps** to all entities
- Use **UUIDs** for primary keys where appropriate

### Authentication & Security

- Start with **JWT tokens** for simplicity
- Design for **future OAuth2/OIDC integration**
- Implement **role-based authorization**
- Use **HTTPS everywhere**
- Apply **CORS policies** properly
- Validate **all inputs** on both client and server

### Docker & DevOps

- Use **multi-stage builds** for optimization
- Implement **health checks** in containers
- Use **docker-compose** for local development
- Apply **least privilege principle** in containers
- Use **.dockerignore** to optimize build context

## Code Quality Standards

### General Rules

- **Write tests first** (TDD approach preferred)
- **Keep functions small** (max 20-30 lines)
- **Use meaningful names** for variables, functions, classes
- **Comment complex business logic**
- **Follow SOLID principles**
- **Apply DRY principle** but avoid premature abstraction

### Error Handling

- Use **structured exception handling**
- Implement **global error handlers**
- Log **all errors** with appropriate levels
- Return **consistent error responses**
- Never expose **internal details** in error messages

### Performance Guidelines

- **Lazy load** Angular modules where possible
- Use **async/await** properly in .NET
- Implement **caching strategies** for frequently accessed data
- **Optimize database queries** (avoid N+1 problems)
- Use **pagination** for large datasets

## Background Agent Guidelines

### Task Assignment

- Assign **specific, well-defined tasks** to background agents
- Provide **clear acceptance criteria**
- Include **relevant context** and constraints
- Specify **testing requirements**

### Agent Collaboration

- Use **clear interfaces** between components worked on by different agents
- Implement **integration tests** to verify agent work compatibility
- Maintain **shared documentation** for cross-agent understanding
- Use **consistent coding standards** across all agent work

### Code Review Process

- Background agents should **create PRs** for review
- Include **comprehensive test coverage**
- Add **clear commit messages** explaining changes
- Update **relevant documentation**

## File Organization

```
/src
  /GarageInventory.API          # Presentation Layer
  /GarageInventory.Application  # Application Layer  
  /GarageInventory.Domain       # Domain Layer
  /GarageInventory.Infrastructure # Infrastructure Layer
  /GarageInventory.Tests        # Test Projects
/frontend
  /src
    /app
      /core                     # Singleton services, guards
      /shared                   # Shared components, pipes, directives
      /features                 # Feature modules
        /auth
        /inventory
        /locations
/docker
  /api
  /frontend
  /database
```

## Naming Conventions

### C# (.NET)

- **PascalCase**: Classes, methods, properties, namespaces
- **camelCase**: Local variables, parameters
- **UPPER_CASE**: Constants
- **Prefix interfaces with 'I'**: IRepository, IService

### TypeScript (Angular)

- **PascalCase**: Classes, interfaces, types, enums
- **camelCase**: Variables, functions, properties
- **kebab-case**: File names, component selectors
- **UPPER_SNAKE_CASE**: Constants

### Database

- **snake_case**: Table names, column names
- **Plural table names**: users, inventory_items, locations
- **Descriptive foreign key names**: user_id, location_id

## Testing Strategy

### Backend Testing

- **Unit tests**: Domain logic, application services
- **Integration tests**: API endpoints, database operations
- **Test coverage**: Minimum 80% for business logic
- **Use test doubles**: Mocks, stubs for external dependencies

### Frontend Testing

- **Unit tests**: Components, services, pipes
- **Integration tests**: Component interactions
- **E2E tests**: Critical user workflows
- **Test utilities**: Page objects, test harnesses

## Documentation Requirements

### Code Documentation

- **XML comments** for public APIs (.NET)
- **JSDoc comments** for TypeScript public methods
- **README files** for each major component
- **Architecture decision records** (ADRs) for significant choices

### API Documentation

- **OpenAPI/Swagger** for REST endpoints
- **Include examples** for request/response bodies
- **Document error responses**
- **Version API endpoints** appropriately

## Environment Configuration

### Development

- Use **local Docker containers** for databases
- **Hot reload** enabled for both frontend and backend
- **Detailed logging** enabled
- **Development-specific configurations**

### Production Considerations

- **Environment-specific configs** via environment variables
- **Secure secret management**
- **Optimized Docker images**
- **Health monitoring** and logging

## Git Workflow

### Branching Strategy

- **main**: Production-ready code
- **develop**: Integration branch
- **feature/***: Feature development
- **hotfix/***: Critical fixes

### Commit Messages

- Use **conventional commits** format
- Include **ticket/issue numbers** where applicable
- Write **clear, descriptive messages**
- **Squash commits** before merging to main

## Background Agent Specific Rules

### When Creating New Features

1. **Start with domain models** and interfaces
2. **Implement business logic** in domain/application layers
3. **Add infrastructure implementations**
4. **Create API endpoints** last
5. **Write tests** throughout the process

### When Modifying Existing Code

1. **Understand existing patterns** before making changes
2. **Maintain backward compatibility** when possible
3. **Update tests** to reflect changes
4. **Update documentation** as needed

### Communication Between Agents

- **Use clear, descriptive branch names**
- **Document breaking changes** in commit messages
- **Create detailed PR descriptions**
- **Tag relevant agents** in PR comments when collaboration is needed

Remember: The goal is maintainable, scalable, and testable code that follows established patterns and practices.
